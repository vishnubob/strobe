#include <pins_arduino.h>

// pins
#define PIN1_PIN            2
#define PIN2_PIN            3
#define PIN3_PIN            4
#define PIN4_PIN            5
#define PIN5_PIN            6
#define PIN6_PIN            7
#define PIN7_PIN            8
#define PIN8_PIN            9
#define PIN9_PIN            10
#define PIN10_PIN           11 
#define PIN11_PIN           12
#define PIN12_PIN           13
#define PIN13_PIN           14
#define PIN14_PIN           15
#define PIN15_PIN           16
#define PIN16_PIN           17

// configurable options
#define PIN_COUNT           16
//#define PIN_COUNT           2 
//#define SLICE_COUNT         1024
#define SLICE_COUNT         512
#define REGISTER_COUNT      3
#define STROBE_FREQ         60
#define CPU_FREQ            16000000

// pin map
const int _pin_map[] = {PIN1_PIN, PIN2_PIN, PIN3_PIN, PIN4_PIN,
                        PIN5_PIN, PIN6_PIN, PIN7_PIN, PIN8_PIN,
                        PIN9_PIN, PIN10_PIN, PIN11_PIN, PIN12_PIN,
                        PIN13_PIN, PIN14_PIN, PIN15_PIN, PIN16_PIN};


// Helper macros for frobbing bits
#define bitset(var,bitno) ((var) |= (1 << (bitno)))
#define bitclr(var,bitno) ((var) &= ~(1 << (bitno)))
#define bittst(var,bitno) (var& (1 << (bitno)))

class ChangeRecord
{
public:
    ChangeRecord() :
        _slice(0), _reg(0), _bit(0), _pin(-1), _onoff(false)
    {}

    /* set */
    inline void set(uint16_t slice, uint8_t pin, bool onoff) 
    { 
        _pin = pin;
        _slice = slice;
        _reg = portOutputRegister(digitalPinToPort(_pin));
        _bit = digitalPinToBitMask(_pin);
        _onoff = onoff;
    }

    /* match */
    inline bool match(uint8_t pin, bool onoff) 
    { return (is_enable() && (_pin == pin) && (_onoff == onoff)); }

    inline bool match(uint8_t pin) { return (is_enable() && (_pin == pin)); }

    /* duplicate */
    inline void duplicate(ChangeRecord &record)
    {
        _slice = record._slice;
        _reg = record._reg;
        _bit = record._bit;
        _pin = record._pin;
        _onoff = record._onoff;
    }

    /* go */
    inline void go()
    {
        if(onoff) { _reg |= _bit; } 
        else { _reg &= ~bit; }
    }

    /* setters */
    inline void disable() { _pin = -1; }

    /* getters */
    inline uint16_t get_slice() { return _slice; }
    inline bool is_enabled() { _pin != -1; }

private:
    uint16_t            _slice;
    volatile uint8_t    *_reg;
    uint8_t             _bit;
    uint8_t             _pin;
    bool                _onoff;
};

class ChangeList
{
public:
    ChangeList :
        _page(false), _action_idx(0), _dirty(false)
    {}

    void add_change(uint8_t pin, uint16_t on, uint16_t off)
    {
        uint8_t next_page = _page ? 0 : 1;
        uint8_t write_ptr = 0;

        _dirty = true;
        if (on == off)
        {
            for(uint8_t idx = 0; idx < PIN_COUNT; ++idx)
            {
                if (!_records[_page][idx].match(pin))
                {
                    _records[next_page][write_ptr++].duplicate(_records[_page][idx]);
                }
            }
            while(write_ptr < PIN_COUNT)
            {
                _records[next_page][write_ptr++].disable();
            }
        } else
        {
            uint8_t read_ptr = 0;
            while(write_ptr < PIN_COUNT)
            {
                if (_records[_page][read_ptr].get_slice() > on)
                {
                    _records[next_page][write_ptr++].set(on, pin, true);
                } else
                if (_records[_page][read_ptr].get_slice() > off)
                {
                    _records[next_page][write_ptr++].set(off, pin, false);
                }
                while (_records[_page][read_ptr].match(pin))
                {
                    ++read_ptr;
                }
                _records[next_page][write_ptr++].duplicate(_records[_page][read_ptr++]);
            }
        }
    }

    inline void flip_page()
    {
        if (!_dirty) { return; }
        _page = _page ? 0 : 1;
        _dirty = false;
    }


    inline uint8_t step()
    {
    }

private:
    ChangeRecord        _records[2][PIN_COUNT];
    uint8_t             _page;
    uint8_t             _action_idx;
    bool                _dirty;
};

ChangeList                  clist;

/******************************************************************************
 ** Setup
 ******************************************************************************/

/*
void test_config(void)
{
    unsigned int offset = 0;
    for(unsigned char idx = 0; idx < PIN_COUNT; ++idx)
    {
        unsigned int on = offset;
        offset += (SLICE_COUNT / PIN_COUNT);
        //offset += 1;
        unsigned int off = (offset >= SLICE_COUNT) ? 0 : offset;
        clist.add_change(idx, on, off);
    }

}
*/

void setup(void)
{
    // setup serial
    Serial.begin(115200);
    Serial.print("... ");
    Serial.flush();
    //test_config();

    /*
    // disable global interrupts
    cli();

    // disable the timer0 interrupt
    // we need the cycles!
    bitclr(TIMSK0, TOIE0);

    // setup timer1 - 16bit
    TCCR1A = 0;
    TCCR1B = 0;
    // select CTC mode
    bitset(TCCR1B, WGM12);
    // 1:1
    bitset(TCCR1B, CS10);
    // set CTC overflow
    OCR1A = CPU_FREQ / SLICE_COUNT / STROBE_FREQ;
    // enable compare interrupt
    bitset(TIMSK1, OCIE1A);

    // enable global interrupts
    sei();
    */

    Serial.println("SetupHardware()");
    Serial.flush();
}

/******************************************************************************
 ** Main Loop
 ******************************************************************************/

// Top level loop, call by the Arduino core
void loop(void)
{
}

/******************************************************************************
 ** Timer Interrupt
 ******************************************************************************/

ISR(TIMER1_COMPA_vect) 
{
    // clist.step();
}
